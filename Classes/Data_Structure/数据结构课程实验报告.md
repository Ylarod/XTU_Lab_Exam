<h1><center>"数据结构"课程实验报告</center></h1>
<br/>

<h2><center>目录</center></h2>



[TOC]


<div STYLE="page-break-after: always;"></div>

## 实验1、复杂度

实验名称：01-复杂度3 二分查找

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.02.25</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>




-------------------------------------------------------------------------------

### 一、实验目的

1. 熟练掌握一般时空复杂度分析技巧
2. 熟练掌握递归程序的时空复杂度分析技巧

### 二、 实验内容

本题要求实现二分查找算法。

#### 函数接口定义：

```c++
Position BinarySearch( List L, ElementType X );
```

其中`List`结构定义如下：

```c++
typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};
```

`L`是用户传入的一个线性表，其中`ElementType`元素可以通过>、==、<进行比较，并且题目保证传入的数据是递增有序的。函数`BinarySearch`要查找`X`在`Data`中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记`NotFound`。

#### 裁判测试程序样例：

```c++
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 10
#define NotFound 0
typedef int ElementType;

typedef int Position;
typedef struct LNode *List;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last; /* 保存线性表中最后一个元素的位置 */
};

List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */
Position BinarySearch( List L, ElementType X );

int main()
{
    List L;
    ElementType X;
    Position P;

    L = ReadInput();
    scanf("%d", &X);
    P = BinarySearch( L, X );
    printf("%d\n", P);

    return 0;
}

/* 你的代码将被嵌在这里 */
```

#### 输入样例1：

```in
5
12 31 55 89 101
31
```

#### 输出样例1：

```out
2
```

#### 输入样例2：

```
3
26 78 233
31
```

#### 输出样例2：

```
0
```

**鸣谢宁波大学 Eyre-lemon-郎俊杰 同学修正原题！**



### 三、程序及注释

```C++
Position BinarySearch( List L, ElementType X ){
    int low = 0;
    int high = L->Last;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (L->Data[mid] == X)
            return mid;
        else if (L->Data[mid] > X)
            high = mid - 1;
        else
            low = mid + 1;
    }
    return NotFound;
}
```

### 四、编译运行结果

![实验1-编译运行结果](https://pic.imgdb.cn/item/5f83e1ab1cd1bbb86bc519fd.png)

### 五、实验心得

学会了二分查找算法,对查找算法有了更深的理解,同时对时空复杂度的分析有了更深的认识




<div STYLE="page-break-after: always;"></div>
## 实验2、线性结构1

实验名称：02-线性结构1 两个有序链表序列的合并

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.04.01</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

1. 熟练掌握循环控制语句
2. 熟练掌握构造新链表方法
3. 熟练掌握链表的遍历查找操作与结点插入操作

### 二、 实验内容

本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。

#### 函数接口定义：

```c++
List Merge( List L1, List L2 );
```

其中`List`结构定义如下：

```c++
typedef struct Node *PtrToNode;
struct Node {
    ElementType Data; /* 存储结点数据 */
    PtrToNode   Next; /* 指向下一个结点的指针 */
};
typedef PtrToNode List; /* 定义单链表类型 */
```

`L1`和`L2`是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数`Merge`要将`L1`和`L2`合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。

#### 裁判测试程序样例：

```c++
#include <stdio.h>
#include <stdlib.h>

typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node {
    ElementType Data;
    PtrToNode   Next;
};
typedef PtrToNode List;

List Read(); /* 细节在此不表 */
void Print( List L ); /* 细节在此不表；空链表将输出NULL */

List Merge( List L1, List L2 );

int main()
{
    List L1, L2, L;
    L1 = Read();
    L2 = Read();
    L = Merge(L1, L2);
    Print(L);
    Print(L1);
    Print(L2);
    return 0;
}

/* 你的代码将被嵌在这里 */
```

#### 输入样例：

```in
3
1 3 5
5
2 4 6 8 10
```

#### 输出样例：

```out
1 2 3 4 5 6 8 10 
NULL
NULL
```

### 三、程序及注释

```C++
List Merge( List L1, List L2 ){
    List r;
    PtrToNode L = ( PtrToNode )malloc( sizeof( struct Node ) );
    List p=L1->Next;
    List q=L2->Next;
    r=L;
    L->Next=NULL;
    while(p!=NULL&&q!=NULL){
        if(p->Data<q->Data){
            r->Next=p;
            p=p->Next;
            r=r->Next;
        }
        else{
            r->Next=q;
            q=q->Next;
            r=r->Next;
        }
    }
    r->Next=NULL;
    if(p!=NULL)    r->Next=p;
    if(q!=NULL)    r->Next=q;
    L1->Next=NULL;
    L2->Next=NULL;
    return L;
}
```

### 四、编译运行结果

![实验2-编译运行结果](https://pic.imgdb.cn/item/5f83e1d01cd1bbb86bc533b9.png)

### 五、实验心得

学会了怎么去定义链表的结点，同时熟悉了对链表的操作，对数据结构有了更深层次的了解




<div STYLE="page-break-after: always;"></div>
## 实验3、最大子列和1

实验名称：01-复杂度1 最大子列和问题

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.02.25</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

通过思考不同算法，找到效率最高的算法来解决最大子列和问题，从而对算法的复杂度分析有更深刻的理解。

### 二、 实验内容

给定*K*个整数组成的序列{ *N*<sub>1</sub>, *N*<sub>2</sub>, ..., N<sub>K</sub> }，“连续子列”被定义为{ *N*<sub>i</sub>, *N*<sub>i+1</sub>, ..., *N*<sub>j</sub> }，其中 1 ≤ *i* ≤ *j* ≤ *K*。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。

本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：

- 数据1：与样例等价，测试基本正确性；
- 数据2：10<sup>2</sup>个随机整数；
- 数据3：10<sup>3</sup>个随机整数；
- 数据4：10<sup>4</sup>个随机整数；
- 数据5：10<sup>5</sup>个随机整数；

### 输入格式:

输入第1行给出正整数*K* (≤100000)；第2行给出*K*个整数，其间以空格分隔。

### 输出格式:

在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。

### 输入样例:

```in
6
-2 11 -4 13 -5 -2
```

### 输出样例:

```out
20
```


### 三、程序及注释

```C++
#include <stdio.h>

int main() {
    int T;
    scanf("%d", &T);
    int sum = 0, max = 0;
    while (T--) {
        int tmp;
        scanf("%d", &tmp);
        sum += tmp;
        if (sum > max) {
            max = sum;
        } else if (sum < 0) {
            sum = 0;
        }
    }
    printf("%d\n", max);
}
```

### 四、编译运行结果

![实验3-编译运行结果](https://pic.imgdb.cn/item/5f83e1d71cd1bbb86bc538c6.png)

### 五、实验心得

学会了在线处理算法

对求最大子列和的各种算法有了更深层次的理解




<div STYLE="page-break-after: always;"></div>
## 实验4、最大子列和2

实验名称：01-复杂度2 Maximum Subsequence Sum

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.02.25</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

通过思考不同算法，找到效率最高的算法来解决最大子列和问题，从而对算法的复杂度分析有更深刻的理解。

### 二、 实验内容

Given a sequence of *K* integers { *N*<sub>1</sub>, *N*<sub>2</sub>, ..., N<sub>K</sub> }. A continuous subsequence is defined to be { *N*<sub>i</sub>, *N*<sub>i+1</sub>, ..., *N*<sub>j</sub> } where 1 ≤ *i* ≤ *j* ≤ *K*. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.

Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.

#### Input Specification:

Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer *K* (≤10000). The second line contains *K* numbers, separated by a space.

#### Output Specification:

For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices *i* and *j* (as shown by the sample case). If all the *K* numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.

#### Sample Input:

```in
10
-10 1 2 3 4 -5 -23 3 7 -21
```

#### Sample Output:

```out
10 1 4
```


### 三、程序及注释

```C++
#include <stdio.h>
int main() {
    int T, A[10005], max = 0, sum = 0, start = 0, tmp_start = 0, end = 0;
    scanf("%d", &T);
    scanf("%d", A);
    max = sum = A[0];
    for (int i = 1; i < T; i++) {
        scanf("%d", A + i);
        if (sum >= 0)
            sum += A[i];
        else {
            sum = A[i];
            tmp_start = i;
        }
        if (sum > max) {
            end = i;
            start = tmp_start;
            max = sum;
        }
    }
    if (max < 0) {
        max = 0;
        start = 0;
        end = T - 1;
    }
    printf("%d %d %d", max, A[start], A[end]);
    return 0;
}
```

### 四、编译运行结果

![实验4-编译运行结果](https://pic.imgdb.cn/item/5f83e1f31cd1bbb86bc54cda.png)


### 五、实验心得

对求最大子列和的在线处理算法有了更深层次的理解




<div STYLE="page-break-after: always;"></div>
## 实验5、线性结构2

实验名称：02-线性结构2 一元多项式的乘法与加法运算

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.04.06</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

熟练掌握链式线性表的基本操作以及在多项式运算上的应用

### 二、 实验内容

设计函数分别求两个一元多项式的乘积与和。

#### 输入格式:

输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。

#### 输出格式:

输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出`0 0`。

#### 输入样例:

```in
4 3 4 -5 2  6 1  -2 0
3 5 20  -7 4  3 1
```

#### 输出样例:

```out
15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1
5 20 -4 4 -5 2 9 1 -2 0
```

### 三、程序及注释

```C++
#include <stdio.h>

struct Poly {
    int ex;
    int co;
} Poly[1001];

int main() {
    int a, b, temp1, temp2, A[2005] = {0}, B[1005] = {0};

    scanf("%d", &a);
    for (int i = 0; i < a; i++) {
        scanf("%d%d", &Poly[i].co, &Poly[i].ex);
        B[Poly[i].ex] += Poly[i].co;
    }
    scanf("%d", &b);
    for (int i = 0; i < b; i++) {
        scanf("%d%d", &temp1, &temp2);
        B[temp2] += temp1;
        for (int j = 0; j < a; j++)
            A[temp2 + Poly[j].ex] += (temp1 * Poly[j].co);
    }
    int isFirst = 1, judge = 0;
    for (int i = 2000; i >= 0; i--) {
        if (A[i] != 0) {
            if (!isFirst) printf(" %d %d", A[i], i);
            if (isFirst) {
                isFirst = 0;
                printf("%d %d", A[i], i);
            }
            judge = 1;
        }
    }

    if (!judge) printf("0 0");
    judge = 0;
    isFirst = 1;
    putchar('\n');
    for (int i = 1000; i >= 0; i--) {
        if (B[i] != 0) {
            if (!isFirst) printf(" %d %d", B[i], i);
            if (isFirst) {
                printf("%d %d", B[i], i);
                isFirst = 0;
            }
            judge = 1;
        }
    }
    if (!judge) printf("0 0");
    return 0;
}
```

### 四、编译运行结果

![实验5-编译运行结果](https://pic.imgdb.cn/item/5f83e2061cd1bbb86bc55a8f.png)


### 五、实验心得

对线性表的链式结构有了更深层次的理解


<div STYLE="page-break-after: always;"></div>
## 实验6、树1

实验名称：03-树1 树的同构

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

熟练掌握二叉树遍历的应用

### 二、 实验内容

给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。



![img](https://images.ptausercontent.com/28)



<center>图1</center>

![img](https://images.ptausercontent.com/29)

<center>图2</center>

现给定两棵树，请你判断它们是否是同构的。



#### 输入格式:

输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数*N* (≤10)，即该树的结点数（此时假设结点从0到*N*−1编号）；随后*N*行，第*i*行对应编号第*i*个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。

#### 输出格式:

如果两棵树是同构的，输出“Yes”，否则输出“No”。

#### 输入样例1（对应图1）：

```in
8
A 1 2
B 3 4
C 5 -
D - -
E 6 -
G 7 -
F - -
H - -
8
G - 4
B 7 6
F - -
A 5 1
H - -
C 0 -
D - -
E 2 -
```

#### 输出样例1:

```out
Yes
```

#### 输入样例2（对应图2）：

```
8
B 5 7
F - -
A 0 3
C 6 -
H - -
D - -
G 4 -
E 1 -
8
D 6 -
B 5 -
E - -
H - -
C 0 2
G - 3
F - -
A 1 4
```

#### 输出样例2:

```
No
```

### 三、程序及注释

```C++
#include <stdio.h>
#define MaxTree 10
#define Null -1
typedef char ElementType;
typedef int Tree;
struct TreeNode {
    ElementType Data;
    Tree Left;
    Tree Right;
} T1[MaxTree], T2[MaxTree];
int N, check[MaxTree];

Tree BuildTree(struct TreeNode T[]) {
    int Root = Null, i;
    char cl, cr;
    scanf("%d", &N);
    if (N) {
        for (i = 0; i < N; i++) check[i] = 0;
        for (i = 0; i < N; i++) {
            scanf("\n%c %c %c", &T[i].Data, &cl, &cr);
            if (cl != '-') {
                T[i].Left = cl - '0';
                check[T[i].Left] = 1;
            } else
                T[i].Left = Null;
            if (cr != '-') {
                T[i].Right = cr - '0';
                check[T[i].Right] = 1;
            } else
                T[i].Right = Null;
        }
        for (i = 0; i < N; i++)
            if (!check[i]) break;
        Root = i;
    }
    return Root;
}

int Isomorphic(Tree R1, Tree R2) {
    if ((R1 == Null) && (R2 == Null)) return 1;
    if (((R1 == Null) && (R2 != Null)) || ((R1 != Null) && (R2 == Null)))
        return 0;
    if ((T1[R1].Data) != (T2[R2].Data)) return 0;
    if ((T1[R1].Left == Null) && (T2[R2].Left == Null))
        return Isomorphic(T1[R1].Right, T2[R2].Right);
    if (((T1[R1].Left != Null) && (T2[R2].Left != Null)) &&
        ((T1[T1[R1].Left].Data) == (T2[T2[R2].Left].Data)))
        return (Isomorphic(T1[R1].Left, T2[R2].Left) &&
                Isomorphic(T1[R1].Right, T2[R2].Right));
    else
        return (Isomorphic(T1[R1].Left, T2[R2].Right) &&
                Isomorphic(T1[R1].Right, T2[R2].Left));
}

int main() {
    Tree R1, R2;
    R1 = BuildTree(T1);
    R2 = BuildTree(T2);
    if (Isomorphic(R1, R2))
        printf("Yes\n");
    else
        printf("No\n");
    return 0;
}
```



### 四、编译运行结果

![实验6-编译运行结果](https://pic.imgdb.cn/item/5f83e2171cd1bbb86bc56b3b.png)


### 五、实验心得

加深了对二叉树结构的了解,对二叉树的遍历更加熟练


<div STYLE="page-break-after: always;"></div>
## 实验7、树2

实验名称：03-树2 List Leaves

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

熟练掌握二叉树的层序遍历



### 二、 实验内容

Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.

#### Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer *N* (≤10) which is the total number of nodes in the tree -- and hence the nodes are numbered from 0 to *N*−1. Then *N* lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a "-" will be put at the position. Any pair of children are separated by a space.

#### Output Specification:

For each test case, print in one line all the leaves' indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.

#### Sample Input:

```in
8
1 -
- -
0 -
2 7
- -
- -
5 -
4 6
```

#### Sample Output:

```out
4 1 5
```

### 三、程序及注释

```C++
#include <bits/stdc++.h>
using namespace std;
#define N 10

typedef struct Node {
    int data, left, right;
} TreeNode;
TreeNode node[N];
TreeNode Queue[N];

int first = -1, last = -1;

void Push(TreeNode tn);
TreeNode Pop();
void printLeaves(int root, int n);

int charToInt(char ch);

int main() {
    int n;
    bool isRoot[N];
    int root;
    scanf("%d\n", &n);
    for (int i = 0; i < n; i++) isRoot[i] = 1;
    for (int i = 0; i < n; i++) {
        char cLeft, cRight;
        scanf("%c %c", &cLeft, &cRight);
        getchar();
        node[i].left = charToInt(cLeft);
        node[i].right = charToInt(cRight);
        node[i].data = i;
        if (node[i].left != -1) isRoot[node[i].left] = 0;
        if (node[i].right != -1) isRoot[node[i].right] = 0;
    }
    for (int i = 0; i < n; i++) {
        if (isRoot[i]) {
            root = i;
            break;
        }
    }
    printLeaves(root, n);
    return 0;
}

void Push(TreeNode treeNode) { Queue[++last] = treeNode; }

TreeNode Pop() { return Queue[++first]; }

void printLeaves(int root, int n) {
    int leaves[N];
    int k = 0;
    Push(node[root]);
    for (int i = 0; i < n; i++) {
        TreeNode tn = Pop();
        if (tn.left == -1 && tn.right == -1) leaves[k++] = tn.data;
        if (tn.left != -1) Push(node[tn.left]);
        if (tn.right != -1) Push(node[tn.right]);
    }
    for (int i = 0; i < k - 1; i++) printf("%d ", leaves[i]);
    printf("%d\n", leaves[k - 1]);
}

int charToInt(char ch) {
    if (isdigit(ch))
        return ch - '0';
    else
        return -1;
}
```



### 四、编译运行结果

![实验7-编译运行结果](https://pic.imgdb.cn/item/5f83e2241cd1bbb86bc5743f.png)


### 五、实验心得

加深了对二叉树结构的了解,对二叉树的层序遍历更加熟练


<div STYLE="page-break-after: always;"></div>
## 实验8、二叉搜索树

实验名称：04-二叉搜索树1 是否同一棵二叉搜索树

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

1. 熟练掌握二叉搜索树的性质
2. 熟练掌握二叉树的遍历

### 二、 实验内容

给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。

#### 输入格式:

输入包含若干组测试数据。每组数据的第1行给出两个正整数*N* (≤10)和*L*，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出*N*个以空格分隔的正整数，作为初始插入序列。最后*L*行，每行给出*N*个插入的元素，属于*L*个需要检查的序列。

简单起见，我们保证每个插入序列都是1到*N*的一个排列。当读到*N*为0时，标志输入结束，这组数据不要处理。

#### 输出格式:

对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。

#### 输入样例:

```in
4 2
3 1 4 2
3 4 1 2
3 2 4 1
2 1
2 1
1 2
0
```

#### 输出样例:

```out
Yes
No
No
```

**鸣谢青岛大学周强老师补充测试数据！**

### 三、程序及注释

```C++
#include <bits/stdc++.h>
using namespace std;
typedef struct treeNode *tree;
struct treeNode {
    int v;
    tree left, right;
    int flag;
};
tree newNode(int V) {
    tree T = (tree)malloc(sizeof(struct treeNode));
    T->v = V;
    T->left = T->right = NULL;
    T->flag = 0;
    return T;
}
tree insert(tree T, int V) {
    if (!T)
        T = newNode(V);
    else {
        if (V > T->v)
            T->right = insert(T->right, V);
        else
            T->left = insert(T->left, V);
    }
    return T;
}
tree makeTree(int N) {
    int V;
    tree T;

    scanf("%d", &V);
    T = newNode(V);
    for (int i = 1; i < N; i++) {
        scanf("%d", &V);
        T = insert(T, V);
    }
    return T;
}
int check(tree T, int V) {
    if (T->flag) {
        if (V > T->v)
            check(T->right, V);
        else if (V < T->v)
            check(T->left, V);
        else
            return 0;
    } else {
        if (V == T->v) {
            T->flag = 1;
            return 1;
        } else
            return 0;
    }
}
int judge(tree T, int N) {
    int V, flag = 0;
    scanf("%d", &V);
    if (T->v != V)
        flag = 1;
    else
        T->flag = 1;
    for (int i = 1; i < N; i++) {
        scanf("%d", &V);
        if (!flag && !check(T, V)) flag = 1;
    }
    if (flag)
        return 0;
    else
        return 1;
}
void reset(tree T) {
    if (T->left) reset(T->left);
    if (T->right) reset(T->right);
    T->flag = 0;
}
void freeTree(tree T) {
    if (T->left) freeTree(T->left);
    if (T->right) freeTree(T->right);
    free(T);
}
int main() {
    int N, L;
    tree T;
    scanf("%d", &N);
    while (N) {
        scanf("%d", &L);
        T = makeTree(N);
        for (int i = 0; i < L; i++) {
            if (judge(T, N))
                printf("Yes\n");
            else
                printf("No\n");
            reset(T);
        }
        freeTree(T);
        scanf("%d", &N);
    }
    return 0;
}
```



### 四、编译运行结果

![实验8-编译运行结果](https://pic.imgdb.cn/item/5f83e2451cd1bbb86bc589a4.png)


### 五、实验心得

对二叉搜索树的性质有了更进一步了解,再次加深了二叉树遍历的理解


<div STYLE="page-break-after: always;"></div>
## 实验9、二叉平衡树

实验名称：04-二叉平衡树1 Root of AVL Tree

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

熟练掌握平衡二叉树的插入与旋转操作

### 二、 实验内容

An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.



![img](https://images.ptausercontent.com/31) ![img](https://images.ptausercontent.com/32)



![img](https://images.ptausercontent.com/33) ![img](https://images.ptausercontent.com/34)

Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.



#### Input Specification:

Each input file contains one test case. For each case, the first line contains a positive integer *N* (≤20) which is the total number of keys to be inserted. Then *N* distinct integer keys are given in the next line. All the numbers in a line are separated by a space.

#### Output Specification:

For each test case, print the root of the resulting AVL tree in one line.

#### Sample Input 1:

```in
5
88 70 61 96 120
```

#### Sample Output 1:

```out
70
```

#### Sample Input 2:

```
7
88 70 61 96 120 90 65
```

#### Sample Output 2:

```
88
```

### 三、程序及注释

```C++
#include <bits/stdc++.h>
using namespace std;
typedef struct AVLTreeNode {
    int Data;
    AVLTreeNode *Left;
    AVLTreeNode *Right;
    int Height;
} nAVLTree, *pAVLTree;

pAVLTree AVLInsertion(int nodeValue, pAVLTree pAvl);
int GetALVHeight(pAVLTree);
pAVLTree SingleLeftRotation(pAVLTree);
pAVLTree DoubleLeftRotation(pAVLTree);
pAVLTree SingleRightRotation(pAVLTree);
pAVLTree DoubleRightRotation(pAVLTree);
int Max(int hight1, int hight2);

int main() {
    int num;
    int i;
    int value;
    pAVLTree pAvl;
    pAvl = NULL;
    cin >> num;
    for (i = 0; i < num; i++) {
        cin >> value;
        pAvl = AVLInsertion(value, pAvl);
    }
    cout << pAvl->Data;
}

pAVLTree AVLInsertion(int nodeValue, pAVLTree pAvl) {
    if (pAvl == NULL) {
        pAvl = (pAVLTree)malloc(sizeof(nAVLTree));
        pAvl->Left = pAvl->Right = NULL;
        pAvl->Data = nodeValue;
        pAvl->Height = 0;
    } else if (nodeValue < pAvl->Data) {
        pAvl->Left = AVLInsertion(nodeValue, pAvl->Left);
        if (GetALVHeight(pAvl->Left) - GetALVHeight(pAvl->Right) == 2) {
            if (nodeValue < pAvl->Left->Data) {
                pAvl = SingleLeftRotation(pAvl);
            } else {
                pAvl = DoubleLeftRotation(pAvl);
            }
        }
    } else if (nodeValue > pAvl->Data) {
        pAvl->Right = AVLInsertion(nodeValue, pAvl->Right);
        if (GetALVHeight(pAvl->Right) - GetALVHeight(pAvl->Left) == 2) {
            if (nodeValue > pAvl->Right->Data) {
                pAvl = SingleRightRotation(pAvl);
            } else {
                pAvl = DoubleRightRotation(pAvl);
            }
        }
    }
    pAvl->Height = Max(GetALVHeight(pAvl->Left), GetALVHeight(pAvl->Right)) + 1;
    return pAvl;
}

pAVLTree SingleLeftRotation(pAVLTree A) {
    pAVLTree B = A->Left;
    A->Left = B->Right;
    B->Right = A;
    A->Height = Max(GetALVHeight(A->Left), GetALVHeight(A->Right)) + 1;
    B->Height = Max(GetALVHeight(B->Left), A->Height) + 1;
    return B;
}

pAVLTree DoubleLeftRotation(pAVLTree A) {
    A->Left = SingleRightRotation(A->Left);
    return SingleLeftRotation(A);
}

pAVLTree SingleRightRotation(pAVLTree A) {
    pAVLTree B = A->Right;
    A->Right = B->Left;
    B->Left = A;
    A->Height = Max(GetALVHeight(A->Left), GetALVHeight(A->Right)) + 1;
    B->Height = Max(GetALVHeight(B->Right), A->Height) + 1;
    return B;
}

pAVLTree DoubleRightRotation(pAVLTree A) {
    A->Right = SingleLeftRotation(A->Right);
    return SingleRightRotation(A);
}

int GetALVHeight(pAVLTree pAvl) {
    if (pAvl == NULL) {
        return 0;
    } else {
        return pAvl->Height;
    }
}

int Max(int hight1, int hight2) { return hight1 > hight2 ? hight1 : hight2; }
```

### 四、编译运行结果

![实验9-编译运行结果](https://pic.imgdb.cn/item/5f83e2511cd1bbb86bc59205.png)


### 五、实验心得

学习了二叉平衡树的插入和旋转操作,并掌握了它们的应用


<div STYLE="page-break-after: always;"></div>
## 实验10、堆

实验名称：05-堆 堆中的路径

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

熟练掌握优先队列(堆)的存储与操作



### 二、 实验内容

将一系列给定数字插入一个初始为空的小顶堆`H[]`。随后对任意给定的下标`i`，打印从`H[i]`到根结点的路径。

#### 输入格式:

每组测试第1行包含2个正整数*N*和*M*(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的*N*个要被插入一个初始为空的小顶堆的整数。最后一行给出*M*个下标。

#### 输出格式:

对输入中给出的每个下标`i`，在一行中输出从`H[i]`到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。

#### 输入样例:

```in
5 3
46 23 26 24 10
5 4 3
```

#### 输出样例:

```out
24 23 10
46 23 10
26 10
```

### 三、程序及注释

```C++
#include <stdio.h>
#include <stdlib.h>
#define MinNum -10000000
typedef struct Stack *minHeap;
struct Stack {
    int *data;
    int maxSize;
    int size;
};
minHeap createHeap(int N) {
    minHeap H = (minHeap)malloc(sizeof(struct Stack));
    if (H == NULL) {
        printf("Error\n");
        return NULL;
    }
    H->data = (int *)malloc((N + 1) * (sizeof(int)));
    H->size = 0;
    H->maxSize = N;
    H->data[0] = MinNum;
    return H;
}
int isFull(minHeap H) { return (H->maxSize == H->size); }
void insert(int num, minHeap H) {
    int i;
    if (isFull(H)) {
        printf("The stack has been full\n");
        return;
    }
    i = ++H->size;
    for (; H->data[i / 2] > num; i /= 2) {
        H->data[i] = H->data[i / 2];
    }
    H->data[i] = num;
}
void printPath(minHeap H, int dot) {
    int i;
    for (i = dot; i > 0; i /= 2) {
        if (i == 1)
            printf("%d", H->data[1]);
        else
            printf("%d ", H->data[i]);
    }
}
int main() {
    int num, N, i, pathNum;
    int topDot[1001];
    scanf("%d %d", &N, &pathNum);
    minHeap H = createHeap(N);
    for (i = 0; i < N; i++) {
        scanf("%d", &num);
        insert(num, H);
    }
    for (i = 0; i < pathNum; i++) {
        scanf("%d", &topDot[i]);
    }
    for (i = 0; i < pathNum; i++) {
        printPath(H, topDot[i]);
        printf("\n");
    }
    return 0;
}
```

### 四、编译运行结果

![实验10-编译运行结果](https://pic.imgdb.cn/item/5f83e25d1cd1bbb86bc599f8.png)


### 五、实验心得

加深了对堆的了解,熟练掌握了堆的存储与操作


<div STYLE="page-break-after: always;"></div>
## 实验11、哈夫曼编码

实验名称：05-哈夫曼编码 哈夫曼编码

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

1.	加深对哈夫曼树的了解（包括合并过程和原理，前缀编码的判断等）
2.	掌握wpl的计算，知道如何建立哈夫曼树
3.	熟悉哈夫曼算法和编码特性
4.	熟练掌握二叉树的遍历

### 二、 实验内容

给定一段文字，如果我们统计出字母出现的频率，是可以根据哈夫曼算法给出一套编码，使得用此编码压缩原文可以得到最短的编码总长。然而哈夫曼编码并不是唯一的。例如对字符串"aaaxuaxz"，容易得到字母 'a'、'x'、'u'、'z' 的出现频率对应为 4、2、1、1。我们可以设计编码 {'a'=0, 'x'=10, 'u'=110, 'z'=111}，也可以用另一套 {'a'=1, 'x'=01, 'u'=001, 'z'=000}，还可以用 {'a'=0, 'x'=11, 'u'=100, 'z'=101}，三套编码都可以把原文压缩到 14 个字节。但是 {'a'=0, 'x'=01, 'u'=011, 'z'=001} 就不是哈夫曼编码，因为用这套编码压缩得到 00001011001001 后，解码的结果不唯一，"aaaxuaxz" 和 "aazuaxax" 都可以对应解码的结果。本题就请你判断任一套编码是否哈夫曼编码。

#### 输入格式：

首先第一行给出一个正整数 *N*（2≤*N*≤63），随后第二行给出 *N* 个不重复的字符及其出现频率，格式如下：

```
c[1] f[1] c[2] f[2] ... c[N] f[N]
```

其中`c[i]`是集合{'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}中的字符；`f[i]`是`c[i]`的出现频率，为不超过 1000 的整数。再下一行给出一个正整数 *M*（≤1000），随后是 *M* 套待检的编码。每套编码占 *N* 行，格式为：

```
c[i] code[i]
```

其中`c[i]`是第`i`个字符；`code[i]`是不超过63个'0'和'1'的非空字符串。

#### 输出格式：

对每套待检编码，如果是正确的哈夫曼编码，就在一行中输出"Yes"，否则输出"No"。

注意：最优编码并不一定通过哈夫曼算法得到。任何能压缩到最优长度的前缀编码都应被判为正确。

#### 输入样例：

```in
7
A 1 B 1 C 1 D 3 E 3 F 6 G 6
4
A 00000
B 00001
C 0001
D 001
E 01
F 10
G 11
A 01010
B 01011
C 0100
D 011
E 10
F 11
G 00
A 000
B 001
C 010
D 011
E 100
F 101
G 110
A 00000
B 00001
C 0001
D 001
E 00
F 10
G 11
```

#### 输出样例：

```out
Yes
Yes
No
No
```

### 三、程序及注释

```C++
#include <bits/stdc++.h>
using namespace std;
int n, m, w, wt, res;
char ch;
string cd[100];
map<char, int> ma;
priority_queue<int, vector<int>, greater<int> > q;

bool cmp(string x, string y) { return x.size() < y.size(); }

int isPrefix() {
    sort(cd + 1, cd + 1 + n, cmp);
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (cd[j].substr(0, cd[i].size()) == cd[i]) return 1;
        }
    }
    return 0;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> ch >> w;
        ma[ch] = w;
        q.push(w);
    }
    while (q.size() >= 2) {
        int x = q.top();
        q.pop();
        int y = q.top();
        q.pop();
        q.push(x + y);
        wt += x + y;
    }
    q.pop();
    cin >> m;
    for (int i = 1; i <= m; i++) {
        res = 0;
        for (int j = 1; j <= n; j++) {
            cin >> ch >> cd[j];
            res += ma[ch] * cd[j].size();
        }
        if (res != wt)
            cout << "No" << endl;
        else if (isPrefix())
            cout << "No" << endl;
        else
            cout << "Yes" << endl;
    }
    return 0;
}
```



### 四、编译运行结果

![实验11-编译运行结果](https://pic.imgdb.cn/item/5f83e2671cd1bbb86bc5a0d8.png)


### 五、实验心得

对哈夫曼算法的编码与特性有了更深的了解,掌握了哈夫曼树的创建等操作


<div STYLE="page-break-after: always;"></div>
## 实验12、散列查找1

实验名称：06-散列查找1 电话聊天狂人 

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.05.06</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

1. 掌握选择部分字段应用除留余数法进行散列映射的技巧
2. 熟练掌握分离链接法解决冲突的机制

### 二、 实验内容

给定大量手机用户通话记录，找出其中通话次数最多的聊天狂人。

#### 输入格式:

输入首先给出正整数*N*（≤10<sup>5</sup>），为通话记录条数。随后*N*行，每行给出一条通话记录。简单起见，这里只列出拨出方和接收方的11位数字构成的手机号码，其中以空格分隔。

#### 输出格式:

在一行中给出聊天狂人的手机号码及其通话次数，其间以空格分隔。如果这样的人不唯一，则输出狂人中最小的号码及其通话次数，并且附加给出并列狂人的人数。

#### 输入样例:

```in
4
13005711862 13588625832
13505711862 13088625832
13588625832 18087925832
15005713862 13588625832
```

#### 输出样例:

```out
13588625832 3
```

### 三、程序及注释

```C++
#include <bits/stdc++.h>

using namespace std;

bool cmp(const pair<long long, int> &p1, const pair<long long, int> &p2) {
    if (p1.second == p2.second) {
        return p1.first < p2.first;
    }
    return p1.second > p2.second;
}

int main() {
    int n;
    map<long long int, int> db;
    scanf("%d", &n);
    long long int tel1, tel2;
    for (int i = 0; i < n; i++) {
        scanf(" %lld %lld", &tel1, &tel2);
        db[tel1] = db[tel1] + 1;
        db[tel2] = db[tel2] + 1;
    }
    vector<pair<long long, int>> arr;
    for (map<long long, int>::iterator it = db.begin(); it != db.end(); ++it) {
        arr.push_back(make_pair(it->first, it->second));
    }
    sort(arr.begin(), arr.end(), cmp);
    int maxnum = arr[0].second;
    int count = 0;
    for (vector<pair<long long, int>>::iterator it = arr.begin();
         it != arr.end(); ++it) {
        if (it->second == maxnum) {
            count++;
        } else {
            break;
        }
    }
    if (count == 1) {
        printf("%lld %d", arr[0].first, arr[0].second);
    } else {
        printf("%lld %d %d", arr[0].first, arr[0].second, count);
    }
    return 0;
}
```

### 四、编译运行结果

![实验12-编译运行结果](https://pic.imgdb.cn/item/5f83e2751cd1bbb86bc5aa49.png)


### 五、实验心得

加深了对散列表的了解，学习了C++ STL中map的使用，同时认识到了Python与C++的性能差距


<div STYLE="page-break-after: always;"></div>
## 实验13、散列查找2

实验名称：06-散列查找2 QQ帐户的申请与登陆

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.05.06</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

1. 掌握选择部分字段应用除留余数法进行散列映射的技巧
2. 熟练掌握用平方探测法解决冲突的机制

### 二、 实验内容

实现QQ新帐户申请和老帐户登陆的简化版功能。最大挑战是：据说现在的QQ号码已经有10位数了。

#### 输入格式:

输入首先给出一个正整数*N*（≤105），随后给出*N*行指令。每行指令的格式为：“命令符（空格）QQ号码（空格）密码”。其中命令符为“N”（代表New）时表示要新申请一个QQ号，后面是新帐户的号码和密码；命令符为“L”（代表Login）时表示是老帐户登陆，后面是登陆信息。QQ号码为一个不超过10位、但大于1000（据说QQ老总的号码是1001）的整数。密码为不小于6位、不超过16位、且不包含空格的字符串。

#### 输出格式:

针对每条指令，给出相应的信息：

1）若新申请帐户成功，则输出“New: OK”；
2）若新申请的号码已经存在，则输出“ERROR: Exist”；
3）若老帐户登陆成功，则输出“Login: OK”；
4）若老帐户QQ号码不存在，则输出“ERROR: Not Exist”；
5）若老帐户密码错误，则输出“ERROR: Wrong PW”。

#### 输入样例:

```in
5
L 1234567890 myQQ@qq.com
N 1234567890 myQQ@qq.com
N 1234567890 myQQ@qq.com
L 1234567890 myQQ@qq
L 1234567890 myQQ@qq.com
```

#### 输出样例:

```out
ERROR: Not Exist
New: OK
ERROR: Exist
ERROR: Wrong PW
Login: OK
```

### 三、程序及注释

```Python
n = input()
db = {}
for i in range(int(n)):
  string = input()
  data = str(string).split()
  if data[0] == "L":
    if data[1] in db.keys():
      if db[data[1]] == data[2]:
        print("Login: OK")
      else:
        print("ERROR: Wrong PW")
    else:
      print("ERROR: Not Exist")
  elif data[0] == "N":
    if data[1] in db.keys():
      print("ERROR: Exist")
    else:
      db[data[1]] = data[2]
      print("New: OK")
```



### 四、编译运行结果

![实验13-编译运行结果](https://pic.imgdb.cn/item/5f83e2821cd1bbb86bc5b38f.png)


### 五、实验心得

Python中的字典就是典型的散列表，本次实验让我对散列表的使用更为了解


<div STYLE="page-break-after: always;"></div>
## 实验14、图的遍历

实验名称：07-图的遍历 列出连通集

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

1. 熟练掌握图的存储与操作
2. 熟练掌握深度优先遍历和广度优先遍历操作

### 二、 实验内容

给定一个有*N*个顶点和*E*条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到*N*−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。

#### 输入格式:

输入第1行给出2个整数*N*(0<*N*≤10)和*E*，分别是图的顶点数和边数。随后*E*行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。

#### 输出格式:

按照"{ *v*1 *v*2 ... *v**k* }"的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。

#### 输入样例:

```in
8 6
0 7
0 1
2 0
4 1
2 4
3 5
```

#### 输出样例:

```out
{ 0 1 4 2 7 }
{ 3 5 }
{ 6 }
{ 0 1 2 7 4 }
{ 3 5 }
{ 6 }
```

### 三、程序及注释

```C++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int matrix[22][22];
int visited[22];
int N, E;
void DFS(int v);
void BFS(int v);
typedef struct Queue *Q;
struct Queue {
    int rear;
    int front;
    int data[22];
};
void DFS(int v) {
    printf("%d ", v);
    visited[v] = 1;
    for (int i = 0; i < N; i++) {
        if (!visited[i] && matrix[v][i] == 1) {
            DFS(i);
        }
    }
}
Q createQueue() {
    Q q = (Q)malloc(sizeof(struct Queue));
    q->front = 0;
    q->rear = 0;
    return q;
}
void push(int data, Q q) {
    q->data[q->rear] = data;
    q->rear++;
}
int pop(Q q) {
    q->front++;
    return q->data[q->front - 1];
}
int isEmpty(Q q) {
    if (q->rear == q->front)  //空的
        return 0;
    else
        return 1;
}
void BFS(int v) {
    Q q = (Q)malloc(sizeof(struct Queue));
    int deleteV, i;
    q = createQueue();
    printf("%d ", v);
    visited[v] = 1;
    push(v, q);
    while (isEmpty(q)) {
        deleteV = pop(q);
        for (i = 0; i < N; i++) {
            if (!visited[i] && matrix[deleteV][i] == 1) {
                printf("%d ", i);
                visited[i] = 1;
                push(i, q);
            }
        }
    }
}
int main() {
    int i, v2, v1;
    scanf("%d %d", &N, &E);
    for (i = 0; i < E; i++) {
        scanf("%d %d", &v1, &v2);
        matrix[v1][v2] = 1;  //两个顶点相关联的
        matrix[v2][v1] = 1;
    }
    for (i = 0; i < N; i++) {
        if (!visited[i]) {
            printf("{ ");
            DFS(i);
            printf("}\n");
        }
    }
    memset(visited, 0, sizeof(visited));
    for (i = 0; i < N; i++) {
        if (!visited[i]) {
            printf("{ ");
            BFS(i);
            printf("}\n");
        }
    }
    return 0;
}
```



### 四、编译运行结果

![实验14-编译运行结果](https://pic.imgdb.cn/item/5f83e28d1cd1bbb86bc5bb32.png)


### 五、实验心得

掌握了图的储存和操作,对DFS算法和图的遍历了解更深


<div STYLE="page-break-after: always;"></div>
## 实验15、深搜

实验名称：07-深度优先搜索 Saving James Bond - Easy Version

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

熟练掌握深度优先遍历的应用

### 二、 实验内容

This time let us consider the situation in the movie "Live and Let Die" in which James Bond, the world's most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape -- he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head... Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot).

Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.

#### Input Specification:

Each input file contains one test case. Each case starts with a line containing two positive integers *N* (≤100), the number of crocodiles, and *D*, the maximum distance that James could jump. Then *N* lines follow, each containing the (*x*,*y*) location of a crocodile. Note that no two crocodiles are staying at the same position.

#### Output Specification:

For each test case, print in a line "Yes" if James can escape, or "No" if not.

#### Sample Input 1:

```in
14 20
25 -15
-25 28
8 49
29 15
-35 -2
5 28
27 -29
-8 -28
-20 -35
-25 -20
-13 29
-30 15
-35 40
12 12
```

#### Sample Output 1:

```out
Yes
```

#### Sample Input 2:

```
4 13
-12 12
12 12
-12 -12
12 -12
```

#### Sample Output 2:

```
No
```

### 三、程序及注释

```C++
#include <math.h>
#include <iostream>
#define MINLEN 42.5

using namespace std;
int n, m;
struct point {
    int x;
    int y;
} p[101];
bool visited[101] = {false};
bool answer = false;

bool firstjump(int i) {
    int a, b, r;
    a = pow(p[i].x, 2);
    b = pow(p[i].y, 2);
    r = (m + 7.5) * (m + 7.5);
    return (r >= (a + b));
}

bool is_safe(int x) {
    if ((p[x].x + m >= 50) || (p[x].x - m <= -50) || p[x].y + m >= 50 ||
        p[x].y - m <= -50)
        return true;
    return false;
}

bool jump(int x, int i) {
    int a, b, r;
    a = pow(p[x].x - p[i].x, 2);
    b = pow(p[x].y - p[i].y, 2);
    r = m * m;
    return (r >= (a + b));
}

bool DFS(int x) {
    visited[x] = true;

    if (is_safe(x)) {
        answer = true;
        return answer;
    }

    for (int i = 0; i < n; i++) {
        if (!visited[i] && jump(x, i)) answer = DFS(i);
    }

    return answer;
}

int main() {
    cin >> n >> m;

    if (m >= MINLEN) {
        cout << "Yes" << endl;
        return 0;
    }

    for (int i = 0; i < n; i++) {
        cin >> p[i].x >> p[i].y;
    }

    for (int i = 0; i < n; i++) {
        if (firstjump(i) && !visited[i])
            if (DFS(i)) break;
    }

    if (answer == true)
        cout << "Yes" << endl;
    else
        cout << "No" << endl;

    return 0;
}
```



### 四、编译运行结果

![实验15-编译运行结果](https://pic.imgdb.cn/item/5f83e2961cd1bbb86bc5c2ac.png)


### 五、实验心得

对DFS算法有了更深刻的了解


<div STYLE="page-break-after: always;"></div>
## 实验16、最短路径

实验名称：08-最短路径 哈利·波特的考试

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

1. 理解单源最短路径和多源最短路径，并能熟练掌握相关的算法过程
2. 对算法复杂度有所了解，知道如何优化相关的算法
3. 熟练掌握图的存储与操作
4. 熟练掌握图的最短距离的计算(弗洛伊德(Floyed)算法)以及推广应用

### 二、 实验内容

哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。

现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。

### 输入格式:

输入说明：输入第1行给出两个正整数*N* (≤100)和*M*，其中*N*是考试涉及的动物总数，*M*是用于直接变形的魔咒条数。为简单起见，我们将动物按1~*N*编号。随后*M*行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。

### 输出格式:

输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。

### 输入样例:

```in
6 11
3 4 70
1 2 1
5 4 50
2 6 50
5 6 60
1 3 70
4 6 60
3 6 80
5 1 100
2 4 60
5 2 80
```

### 输出样例:

```out
4 70
```

### 三、程序及注释

```C++
#include <stdio.h>
#include <string.h>
int map[101][101];
int visited[101];
int dist[101];
int N, M;
int findMinDist() {
    int i, minDist = 99999999, minV;
    for (i = 1; i <= N; i++) {
        if (!visited[i] && dist[i] < minDist) {
            minDist = dist[i];
            minV = i;
        }
    }
    if (minDist < 99999999)
        return minV;
    else
        return -1;
}
int Dijkstra(int start) {
    int i, j;
    for (i = 1; i <= N; i++) {
        if (map[start][i] || i == start)
            dist[i] = map[start][i];
        else
            dist[i] = 99999999;
    }
    dist[start] = 0;
    visited[start] = 1;
    while (1) {
        int ver = findMinDist();
        if (ver == -1) break;
        visited[ver] = 1;
        for (i = 1; i <= N; i++) {
            if (!visited[i] && map[ver][i]) {
                if (dist[ver] + map[ver][i] < dist[i]) {
                    dist[i] = dist[ver] + map[ver][i];
                }
            }
        }
    }
}
int getMaxLen() {
    int i, max = -111;
    for (i = 1; i <= N; i++) {
        if (max < dist[i]) max = dist[i];
    }
    return max;
}

int judgeGraphLinked() {
    int i;
    for (i = 1; i <= N; i++) {
        if (dist[i] == 99999999) return 1;
    }
    return 0;
}
int main() {
    int animal1, animal2, len, i, j;
    int minLen = 99999999, minAni = 9999, reLen, flag, judge = 1;
    scanf("%d %d", &N, &M);
    for (i = 0; i < M; i++) {
        scanf("%d %d %d", &animal1, &animal2, &len);
        map[animal1][animal2] = len;
        map[animal2][animal1] = len;
    }
    for (i = 1; i <= N; i++) {
        flag = 0;
        memset(visited, 0, sizeof(visited));
        memset(dist, 0, sizeof(dist));
        Dijkstra(i);
        if (judgeGraphLinked()) {
            judge = 0;
            break;
        }
        reLen = getMaxLen();
        if (reLen < minLen) {
            minLen = reLen;
            flag = 1;
            if (flag) {
                minAni = i;
            }
        }
    }
    if (judge)
        printf("%d %d\n", minAni, minLen);
    else
        printf("0\n");
    return 0;
}
```



### 四、编译运行结果

![实验16-编译运行结果](https://pic.imgdb.cn/item/5f83e2a51cd1bbb86bc5ce34.png)

### 五、实验心得

1. 多源最短路径目前的算法就是floyd，算法复杂度是o（n^3），也没有什么优化算法，但是这个算法很短，也好理解，其原理和单源最短路径的算法Dijkstra差不多

2. Floyd算法的核心就是路径的收缩，假设目前有a到b的最短路径，长为c，当考察一条边d的时候，发现a到b的最短路，可以经过a到c的最短路和c到b的最短路压缩变得更短，那么就更新，过程是完全暴力循环的




<div STYLE="page-break-after: always;"></div>
## 实验17、最小生成树

实验名称：09-最小生成树 公路村村通

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

1. 要求我们了解树的定义，树只有一个跟，并且n个顶点的树，只有n-1条边。

2. 加深对最小生成树的理解，并掌握两个基本算法，prim和kruskal算法，理解其过程并能熟练掌握其代码

3. 熟悉对于kruskal算法的操作，也要能熟练掌握

### 二、 实验内容

现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。

#### 输入格式:

输入数据包括城镇数目正整数*N*（≤1000）和候选道路数目*M*（≤3*N*）；随后的*M*行对应*M*条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到*N*编号。

#### 输出格式:

输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。

#### 输入样例:

```in
6 15
1 2 5
1 3 3
1 4 7
1 5 4
1 6 2
2 3 4
2 4 6
2 5 2
2 6 6
3 4 6
3 5 1
3 6 1
4 5 10
4 6 8
5 6 3
```

#### 输出样例:

```out
12
```

### 三、程序及注释

```C++
#include <stdio.h>
#include <string.h>
int map[1001][1001];
int minCost[1001];
int visited[1001];
int N, M;
int min(int a, int b) { return a > b ? b : a; }
int prime() {
    int i, sum = 0, v;
    for (i = 1; i <= N; i++) minCost[i] = 99999999;
    minCost[1] = 0;
    while (1) {
        v = -1;
        for (i = 1; i <= N; i++) {
            if (!visited[i] && (v == -1 || minCost[v] > minCost[i])) v = i;
        }
        if (v == -1) break;
        if (minCost[v] == 99999999) return 0;
        visited[v] = 1;
        sum += minCost[v];
        for (i = 1; i <= N; i++) {
            if (map[v][i]) minCost[i] = min(minCost[i], map[v][i]);
        }
    }
    for (i = 1; i <= N; i++) {
        if (!visited[i]) return 0;
    }
    return sum;
}
int main() {
    int i;
    int city1, city2, cost;
    scanf("%d %d", &N, &M);
    for (i = 0; i < M; i++) {
        scanf("%d %d %d", &city1, &city2, &cost);
        map[city1][city2] = cost;
        map[city2][city1] = cost;
    }
    int sum = prime();
    if (sum)
        printf("%d\n", sum);
    else
        printf("-1\n");
    return 0;
}
```



### 四、编译运行结果

![实验17-编译运行结果](https://pic.imgdb.cn/item/5f83e2b31cd1bbb86bc5d841.png)

### 五、实验心得

1. 最小生成树有两种算法，prim和kruskal，其中prim算法一般用于稠密图，朴素的prim算法时间复杂度是o（n^2），用优先队列优化后是o（n*logn）但是优化实现起来麻烦，还不如用kruskal

2. Kruskal算法中还有一个并查集的操作，这个数据结构实现起来很简单，它可以进行优化（包括按秩合并以及路径压缩），效率极高




<div STYLE="page-break-after: always;"></div>
## 实验18、排序

实验名称：10-排序 排序

班级 <u>[班级]</u>      姓名 <u>[姓名]</u>       学号<u>[学号]</u>       实验日期：<u>2020.07.28</u>

<div style="float:left; text-align:left">实验机时：2 学时</div>
<div style="float:right; text-align:right; margin-right: 50px;">实验成绩：</div>



-------------------------------------------------------------------------------

### 一、实验目的

1. 熟练掌握各种排序算法
2. 了解各种排序算法在不同数据情况下的表现

### 二、 实验内容

给定*N*个（长整型范围内的）整数，要求输出从小到大排序后的结果。

本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下：

- 数据1：只有1个元素；
- 数据2：11个不相同的整数，测试基本正确性；
- 数据3：10<sup>3</sup>个随机整数；
- 数据4：10<sup>4</sup>个随机整数；
- 数据5：10<sup>5</sup>个随机整数；
- 数据6：10<sup>5</sup>个顺序整数；
- 数据7：10<sup>5</sup>个逆序整数；
- 数据8：10<sup>5</sup>个基本有序的整数；
- 数据9：10<sup>5</sup>个随机正整数，每个数字不超过1000。

#### 输入格式:

输入第一行给出正整数*N*（≤10<sup>5</sup>），随后一行给出*N*个（长整型范围内的）整数，其间以空格分隔。

#### 输出格式:

在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。

#### 输入样例:

```in
11
4 981 10 -17 0 -20 29 50 8 43 -5
```

#### 输出样例:

```out
-20 -17 -5 0 4 8 10 29 43 50 981
```

### 三、程序及注释

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    int i,j;
    cin >> i;
    vector<int> intlist;
    while(i--){
        cin >> j;
        intlist.push_back(j);
    }
    sort(intlist.begin(),intlist.end());
    cout << intlist[0];
    for(auto iter = intlist.begin()+1; iter != intlist.end(); iter++){
        cout << " " << *iter;
    }
}
```

### 四、编译运行结果

![实验18-编译运行结果](https://pic.imgdb.cn/item/5f83e2be1cd1bbb86bc5e014.png)


### 五、实验心得

学习了C++ STL库中的sort函数使用，并使用它进行排序,且认识到了该函数的稳定可靠！